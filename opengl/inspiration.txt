<点>
说到3D Graphics， 当然最基本的元素就是点了，我们就从点着手，逐步撑起整个架构。
那么，到底一个点应该包含什么信息呢？ 当然是几何信息和物理信息啦。

<点的位置>
点的几何信息主要的就是其位置信息，那么，位置的计算机表示是什么呢？
1. float[4] 齐次坐标 2. float[3] 普通三维坐标  3. float[2]  普通二维坐标  4. int[2] 视口坐标
这4个坐标间的转换又蕴含着我们对位置的操作，也就是变换。 我们所谓的变换，其实就是两个坐标系
之间的点的对应关系(注意，不一定是一一对应)。 那么，变换有哪几种呢？
1. modelview transform，指的是物体的局部坐标系到世界坐标系的变换， 或者是世界坐标系到相机
局部坐标系的变换， 这两种变换实际是一类，都是三维坐标系到三维坐标系的变换，也就是齐次坐标
到齐次坐标的变换(记作1-->1)。注意变换的顺序
一般是不可颠倒的，因为矩阵乘法是不可交换的。
2. projection transform， 这是指的相机坐标系到一个2维平面的变换，指的是将一个frustum里的东东
投影到一个平面，分为正交投影和透视投影， 这个变换经历两个过程，首先将齐次坐标(x,y,z,w)变成
(x/w, y/w, z/w)， 然后再变成(x', y')， 即1-->2-->3
3. viewport transform， 将抽象出的二维平面(-1~1, -1~1)映射到视口坐标。

说了变换的通用概念，那么OPENGL里面是怎么实现变换的呢？
opengl用4x4矩阵来描述变换，而且opengl prefer的矩阵表示是float[16]这样的列优先的一维数组。
并且在client端通过矩阵乘法得到modelview projection matrix以后，pass给服务端的shader来处理。
因此对于程序人员来说，最好是维护两个matrix stack，一个用来维护modelview transform， 另一个
用来维护projection transform。 并且用一个transform pipeline的结构，通过组合的方式，存储
前面两个栈的指针，通过set和get来统一管理transform相关的东东。 同时，对于需要动态移动的物体，
如相机，我们最好用一个frame的类来提供一系列移动旋转的结构，再提供一个getMatrix来得到最终的
变换矩阵，以操作matrix stack。 当然，这一系列的东东都离不开数学，所以我们需要实现一个小型
的3D数学的库来支撑。
</点的位置>

<点的颜色>
首先，我们需要明确的是颜色的格式以及对应的存储形式:
颜色的格式有RGB，RGBA等等， 对应的存储结构为float[3], float[4]， 当然还有很多其他的颜色格式，
这里就不一一列举了。
说完了颜色的表示方式，那么一个点的颜色到底由哪些东西决定呢？注意，我们这里指的点的颜色，其实
是说的点反射到我们眼睛里形成的颜色。所以，其决定因素有如下几个，我们分别来介绍：
1. 材质
新版本的OPENGL已经弱化了材质的概念，我们可以把它简单理解为一个基础的颜色值float[4]
2. 纹理
说到纹理，这里的东西就多了。
首先，纹理的最重要的东西肯定就是raw image data咯， 就是说这个纹理的内容是什么，这里牵涉到
image在磁盘上的存储格式，在内存里的排列等等，在opengl里面我们可以控制纹理在内存中的PACK形式。
我们可以从磁盘里读取image的bytes到内存，再从内存里load到texture object， 也可以直接从color
buffer里面copy像素到texture object，load texture牵涉到一些格式的东西，可以查阅资料。
再来就是说说纹理映射的东东， 纹理映射是怎样一个过程呢？首先，我们会指定多边形顶点对应的纹理
坐标(0~1, 0~1)， 然后在像素计算的时候，我们会根据该像素所在三角形的三个点的坐标插值出该像素
的对应纹理坐标，然后根据纹理滤波的方法(下面会介绍)，得到其纹理的RGB值。
所谓纹理滤波，指的就是怎么根据纹理坐标去纹理图像上找对应颜色值。
常见的纹理滤波方式有最近像素滤波和线性滤波，最近像素滤波指的是找最近的像素，容易产生块状现象，
而线性滤波指的是找到其周围的多个像素取平均，容易产生平滑模糊的现象。 
mipmapping是用来解决锯齿问题的一个方法，其做法是采用多级分辨率的纹理图像，配合纹理滤波，用
最接近目标尺寸的两个纹理贴图来插值出合适的像素值，称作三线性插值。
各向异性滤波是一个更牛逼的技术，在观察视线不垂直目标的时候，目标会或多或少朝某些方向拉伸或
缩短，这样原始的正方形采样就不准确了，需要矩形采样或者梯形之类的。。
最后，opengl还提供了纹理压缩的接口，可以使得放进显存里的纹理小一些，纹理切换快一些。当然这会
在压缩的时候消耗多一些时间。

3. 光照模型
这里牵涉的东东也蛮多的，光照模型是控制颜色的一个核心。它可以让我们实现N多特殊效果，光照模型
一般在顶点着色器里实现，它能根据入射光的角度，强度，点的法向量，距离等因素，实现各种不同的
光强度的函数，可以实现神码暖色调，卡通之类的效果。
</点的颜色>
</点>

<基元>
将点连接成一些基本的元素就成了OPENGL里的基元，我们这里只讲最基本的三角形，因为GPU最后光栅化
的时候也通常是按三角形来填充和扫描的。
三角形我们如果不要求性能和效率等，可以直接用顶点表示，如果将效率考虑进去，就弄个索引就完事。
由于graphics 3D里面的插值神码的基本是基于三角形的，所以三角形是灰常重要的啦，比如纹理坐标
插值，光照颜色插值等等。。
</基元>
