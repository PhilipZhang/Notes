
------------------------------------数组和指针在声明和定义须一致-----------------------------------------------------------------------------------------------------------------------------------
左值指一个变量的地址， 右值指一个变量的内容(即那个地址的内容)
编译时编译器会分配给各个变量地址，因此左值在编译时确定，但是右值须待运行时确定。

当一个变量被定义为数组时， 声明的时候也必须用数组， 不能用指针，反过来也一样：
file1.c:
char a[100];

file2.c:
extern char *a; // wrong!
extern char a[]; // right!

这是因为编译器对待数组和指针，在获得其指向的值时候有不一样的态度： 数组就一块数据，而指针是存储某地址的单个变量。当数组
要改变指向的对象时，只用加上一个偏移就可以改变，而指针需先得到其变量的右值，然后再进行解引用

------------------------------------四种不同形式定义的内存分布-----------------------------------------------------------------------------------------------------------------------------------
考虑在某函数里定义如下四种形式:
int p[3][5];   所有数组变量均存储在该栈的连续区域，编译时在符号表中只有一个p,表示数组的起始地址。
int *p[3];     栈中开辟一个一维数组p,大小为3，用来存放地址。具体地址指向哪儿，需要运行时确定，因为其是右值。
int (*p)[5];   栈中开辟一个位置存放地址，符号表中放入p，表示这个地址的地址。
int **p;       栈中开辟一个位置存放地址，符号表中放入p，表示这个地址的地址。
当我们用 p[i][j]时，虽然对于以上四种定义，我们的书写接口都一样，并且编译器翻译为*(*(p+i)+j)也一样，但是访问方式完全不同。
(1) 在符号表中找到p, 表示其在栈中的地址， 假设为5080。 然后将i scale 行的长度(5*4), 将j scale 4，再(5080+5*4*i+4*j)得到地址ADDR， 最后访问该地址内容[ADDR]
(2) 在符号表中找到p, 假设为5080, 然后将i scale 指针的大小(假设为64), 然后访问5080+i*64地址的内容, say 7004 = [5080+i*64], 再访问[7040+4*j]
(3) 在符号表中找到p, 假设为5080, 然后获得[5080] = 6040, 然后将i scale 5*4, 将j scale 4, 最后访问[6040 + 5*4*i + 4*j]
(4) 跟3的相似， 但是要具体根据p指向的数组的大小


对于
char text[] = "today is beautiful";
char *text = "today is beautiful";
前者在字符串常量区创建一个 "today is beautiful", 并且拷贝一份到当前栈(char 在函数中定义)或者全局区(global 或 local变量), 可以改变text指向的内容。
后者仅仅在字符串常量区创建一个字符串，并将指针指向它，但是这个区域是不允许改变的。


------------------------------------将数组作为函数参数-----------------------------------------------------------------------------------------------------------------------------------
对于函数传参：
记住一条规则即可应对无论多少维的数组或指针
即编译器将数组的第一维转化为指向该数组第一维第一个元素的指针(若数组为N维，则是指向第一个N-1维数组的指针，decay into pointer。)，若传递的本来就是一个指针，那么直接拷贝即可
所以为什么我们可以将 main中的argv写成 char** argv, 那是因为其本身是 char *argv[], 所以在传递的时候会decay into pointer.
由于数组decay into pointer, 所以在函数中没法知道数组的大小，有两种办法，一种是附加一个参数指明数组大小，另一个办法是在数组末尾加一个特殊标记，指明为数组到尾了(如字符串)

------------------------------------任意长数组-----------------------------------------------------------------------------------------------------------------------------------
让我们来上升一个高度，对于一个函数，如何让它处理任意长度的数组？
其实在上面的对比下，我们已经看出了数组和指针的区别，所以要达到任意长度，数组是不能够做到的，因为它规定了长度，但是我们可以手动的将其转化为指针，并且在每一维结束的地方加
上特殊的标记(我们用char类型来举例，因为其拥有特殊的结束符'\0', 其他类型需要自己规定一个结束符)：
一维： func(char [])  由于编译器自动将其转化为指针处理，所以一维情况可以将任意长度的char数组作为实参传递进去
二维： func(char [][5])  这种声明规定了每个row只能有5个列宽  char a[3][5];  char b[4][6];   func(a); // ok   func(b); // wrong
	   func(char **) 或 func(char []*), 这两种声明在编译器看来都是一样的， 最后都为func(char **)。 由于数组 char a[4][10]; decay into pointer 以后变为char (*a)[10]， 并不能
	   func(char **)， 所以如果调用func(a)会出错，究其原因还是在于编译器处理数组和指针的手段不同。 所以要想达到通配的方法， 可以手动将char a[4][10]  转化为char *a[4]; 然后再
	   调用通配函数， 即不会出错。 我们的int main(int argc, char** argv)就是这样设计的。记住，这种情况虽然每列的结尾能够通过'\0'判断， 但是并不知道行的结尾，所以需要用一个
	   argc来指明有多少行。
三维： 没有通用方法。 用到什么size就声明什么size,  除非手动降维。C中缺乏对多维数组作为函数参数的支持，导致了用它写一些特殊用途(如数值分析)的程序非常困难。

------------------------------------总结-----------------------------------------------------------------------------------------------------------------------------------
上面总结了这么多， 有两个核心是应该要铭记于心的：
1. 大小需要动态来确定的，需要用指针instead of数组。
2. 数组和指针在编译器眼里是不同的东西，所以声明和定义须匹配，函数调用时(特别是多维的时候)需要谨慎处理，一般表达式的时候虽然获取值的方式不同，但是最后结果是一样的，所以可以视作等价。
对于函数调用，只用看实参数组decay下来匹不匹配函数形参即可。


注意， a pointer to something 代表者这个pointer的跨度就是这么大, 如：
int (*par())[20]
表示函数返回一个跨度为int[20]的指针。
之所以这里用跨度， 是说明指针不止包含着地址的信息， 还包含着类型信息。


------------------------------------动态增长的数据结构-----------------------------------------------------------------------------------------------------------------------------------
1. 用realloc, 在不够时重新分配一个更大的内存空间，有可能会将空间整块移动，造成系统瞬间负荷大
2. 用链表，对于增加元素只用链接上去，但是随机访问是硬伤
