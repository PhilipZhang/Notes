
--------------------------SHELL基础----------------------------------------

shell: 替我们工作的是硬件，控制硬件的是kernel,我们使用者则是利用shell控制
一些kernel提供的工具utility，来操控硬件替我们正确的工作。
bash shell: 是GNU操作系统中标准的shell,兼容sh,并作了增强。
BASH的主要优点：
1. 命令编修能力
2. 档案比对补全(指令补全，档案补全)
3. 命令别名(alias)设定功能
4. 工作控制，前景背景控制
5. shell scripts

当用户登录成功，主机就已经丢了一个称为bash的程序给其操作。

--------------------------变量与变量的设定----------------------------------

echo 显示变量内容
env 显示环境变量
set 显示系统所有变量

变量设定规则:
1. 变量与变量内容以=来链接
2. =两侧不能直接接空格
3. 变量名称只能是英文与数字，且不能以数字开头
4. 若有空格符的可以用 ""或'',""内的保持变量特性,''内的特殊字符仅为一般字符
5. 用\可以将特殊符号变成一般符号(如enter,$,\,空格副,`等)
6. unset来取消变量
7. 若该变量为扩增变量内容时，需双引号变量名称，如 "$PATH":/home
8. 若该变量需要在其他子程序执行，则需要以export来完成。
9. 指令中含指令的，可以用`command`(是1旁边这个符号).

read 由用户键盘输入变量内容
数组: a[1]=3  a[2]=4   echo ${a[1]}

--------------------------命令别名与历史命令---------------------------------

alias rm='rm -i'
unalias
history 查询曾经使用过的指令
!command  !60 执行第60个历史指令  !! 执行上一个指令  !ll 执行最近一次以ll开头的指令
每个用户的历史指令被记录在~/.bash_history文件里

--------------------------系统设定与个人设定---------------------------------

在指令列设定的变量和alias都是针对当次登录， 一旦注销， 就会消失。
因此我们需要几个档案来帮助我们需要长久记录的设定值。
1.系统设定值(每个使用者进入到bash以后，会先读取的配置档案)
/etc/profile system wide .profile for bash shell 
/etc/bashrc  规划umask功能，也同时规划出提示字符的内容

2.个人设定值(个人喜好设定, 个人家目录的隐藏文件)
~/.bash_profile 或 ~/.profile 或 ~/bash_login， 记录了个人路径PATH以及环境变量的文件名
~/.bashrc 个人变量的设定
~/.bash_history 对于本次登录的指令，在离开shell时，才会写入该文件， 该文件的指令
笔数与HISTFILE有关，可以自行在~/.bashrc里设定，也可以由root在/etc/profile里统一
设定
~/.bash_logout 记录注销时,BASH会为我做的事情，通常只有clear，但可以手动加。
source  将更改的配置文件直接读入，无需logout

--------------------------通配符与特殊符号---------------------------------
1. 符号
* 通配符，表示任意多个字符
? 通配符，表示一个字母
# comment
\ 跳脱符，将特殊符号还原成一般字符
| 管线命令的界定
; 连续性命令的界定
~ 用户的家目录
$ 变量符
& 将指令变成在背景下工作
>,>> 输出导向
'' 单引号，不具有变量置换功能
"" 双引号，具有变量置换功能
`` 中间为可以先执行的指令
() 中间为子shell的起始与结束
[] 中间为字符的组合
{} 中间为命令区块的组合


2. 组合按键
Ctrl+C 终止目前的命令
Ctrl+D 输入结束(EOF), 例如邮件结束的时候
Ctrl+M 就是Enter
Ctrl+S 暂停屏幕的输出
Ctrl+Q 恢复屏幕的输出
Ctrl+U 在提示字符下 将正列命令删除
Ctrl+Z 暂停目前的命令

3. ;,&&,||的区别
command1 XX command2
;表示无论命令1结果如何都执行命令2
&& 表示只有命令1结果正确执行命令2
|| 表示只有命令1结果错误执行命令2

--------------------------命令重导向---------------------------------

< 由<右边读入参数档案,将原本需要屏幕输入的改为由档案输入, stdin
> 将原本由屏幕输出的正确结果导向至文件或装置(如printer), stdout
>> 将原本由屏幕输出的正确结果以累加的方式导向至文件或装置 
2> 将原本由屏幕输出的错误结果导向至文件或装置, stderr 
/dev/null 可以理解为黑洞装置,数据丢弃

命令重导向的使用场合:

当屏幕输出的信息很重要，而且我们需要将他存下来的时候；
背景执行中的程序，不希望他干扰屏幕正常的输出结果时；
一些系统的例行命令（例如写在 /etc/crontab 中的档案）的执行结果，希望他可以存下来时；
一些执行命令，我们已经知道他可能的错误讯息，所以想以『 2> /dev/null 』将他丢掉时；
错误讯息与正确讯息需要分别输出时。

--------------------------管线命令---------------------------------

bash命令执行的时候有输出的数据会出现，如果这批数据需要经过几道手续才能得到
我们想要的格式，则涉及到管线命令

command1  |   command2   |  command3
->stdout->stdin ->stdout ->stdin           
简而言之， 管线命令只能将正确结果作为输出导向到下一个管线命令

基本管线命令：
1.cut  以特定字符分割同一行里的数据 cat /etc/passwd | cut -d ":" -f 1 
2.sort 以行为单位进行排序
3.wc(word count)  -l 多少行   -w  多少单词
4.uniq 删除重复行只保留一行,用uniq之前需要先sort，否则无效
5.tee 同时将数据传给管线中下一个命令以及输出到文件 last | tee last.list | cut -d " " -f1
6.tr translate or delete one set (to another)  last | tr [a-z] [A-Z]
7.split  以大小或行数分割档案至多个档案 split -l 10 /etc/passwd test
8.grep 取满足某个模式的行
